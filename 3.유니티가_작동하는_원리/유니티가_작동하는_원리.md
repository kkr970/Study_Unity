### 상속과 재사용
기초를 제공하는 클래스는 부모클래스, 부모 클래스를 상속받아 확상한 클래스를 자식 클래스라고 부름  
상속을 이용해 코드의 재사용을 높일 수 있음  
* 게임 속 몬스터인 오크, 오크대장을 만들기 위해 몬스터 클래스 구현  
```cpp
class Monster
{
    인공지능
    애니메이션
    공격, 방어
    물리엔진
    etc;
}
class Orc : Monster
{
    (몬스터 기능)
    오크 외형
    오크 애니메이션
    오크 스킬
    오크 고유 기능
}
class OrcChiftan : Orc
{
    (오크 기능)
    대장 외형
    새로운 무기, 새로운 공격
    대장 고유기능
}
```
그러나, 상속에 의존하게 된다면 코드를 재사용하기 힘들어지는 경우도 있음
* 게임 속 NPC, 플레이어, 몬스터를 만들기 위한 Human 클래스 구현  
```cpp
class Human
{
    랜더링
    물리엔진
    애니메이션
    체력
}
```
* Human 클래스를 이용하여 Player 구현
```cpp
class Player : Human
{
    (Human 기능)
    조작
    공격
    직접
}
```
* Human 클래스를 이용하여 NPC 구현
```cpp
class NPC : Human
{
    (Human 기능)
    (제거)물리엔진
    (제거)
    대화
    거래
}
```
이 때, NPC에는 필요없는 물리엔진과 체력을 제거해야 하는 추가 작업이 생김  
* Human 클래스를 이용하여 Monster 구현
```cpp
class Monster : Human
{
    (Human 기능)
    (변경)애니메이션 → 몬스터 애니메이션
    (변경)물리엔진 → 몬스터 물리엔진
    인공지능
    공격
}
```
Human의 애니메이션은 사람 형태의 뼈대를 이용하였기에 다른 모습을 가진 몬스터는 다른 애니메이션으로 변경  
물리 엔진도 동일한 이유로 변경  
상속에 의존하게 된다면 자식 클래스를 만들때 필요한 기능이 무엇인지 추측하기 힘들기에 매번 번거로운 일이 생김  
이를 해결하기 위해 컴포넌트 패턴을 사용함  

---------------------------------------------
### 컴포넌트 패턴
컴포넌트 패턴 또는 컴포지션 패턴은 미리 만들어진 부품을 조립해 오브젝트를 만드는 방법  
여기서 미리 만들어진 부품이 컴포넌트라고 부름  
  
1. 컴포넌트로 동물 만들기  
컴포넌트를 미리 여러개 생성  
  * 컴포넌트 주머니
```
폐, 지느러미, 아가미, 잠자기, 탯줄, 다리, 뿔, 날개, 밥먹기, 알 낳기
```
각 부품들은 나중에 어떻게 사용할 것인지 알 수 없으며, 하나의 부품당 하나의 능력(역할)을 가짐  
  
2. 빈 게임 오브젝트 만들기  
코뿔소를 만들기 위해서 게임 오브젝트를 만듬  
* 코뿔소 게임 오브젝트
```

```
현재 오브젝트는 빈 오브젝트이기에 아무것도 없지만, 컴포넌트를 붙일 수 있는 홀더 역할을 함  
  
3. 코뿔소 게임 오브젝트 완성하기  
코뿔소 게임 오브젝트에 원하는 기능을 가진 컴포넌트를 찾아 게임 오브젝트에 넣어서 실질적인 기능을 부여함  
* 코뿔소 게임 오브젝트
```
폐, 다리, 밥먹기, 뿔, etc...
```
이로써 코뿔소 게임 오브젝트가 완성됨  
  
4. 다른 게임 오브젝트 생성하기  
코뿔소 처럼 다른 동물의 오브젝트도 동일한 방법으로 제작이 가능함  
  
<br></br>
컴포넌트 방식의 장점
* 유연한 재사용이 가능함
* 기획자의 프로그래머 의존도가 낮아짐
* 독립성을 가지기에 기능의 추가, 삭제가 쉬움
---------------------------------
### 유니티 에디터에서의 컴포넌트
유니티에서 게임 오브젝트는 컴포넌트 구조를 가지고 있음  
1장에서 사용한 큐브 오브젝트가 가지고 있는 컴포넌트는 트랜스폼, 메시 필터, 메시 렌더러, 박스 콜라이더, 리지드바디를 가지고 있었음  
각 컴포넌트들이 가진 기능이 큐브 오브젝트를 구성하고 있으며, 필요할 때 삭제나 새로운 기능을 추가할 수 있음  

-----------------------------------
### 메시지와 브로드캐스팅
컴포넌트 구조에서 '전체 방송'을 통해 특정 기능을 간접적으로 실행하는데, 이 방송을 브로드캐스팅 이라고 함  
* MonoBehaviour
    * 모든 컴포넌트의 기반, 모든 컴포넌트가 상속하고 있는 클래스
    * 유니티가 제공하는 클래스, 컴포넌트들의 기본 기능을 제공함
        * 즉, 사용자가 만드는 class도 MonoBehaviour을 상속하면 컴포넌트로 사용할 수 있음
    * 유니티의 메시지를 들을 수 있게 함
* 유니티 메시지
    * 컴포넌트들은 서로 접점이 없기 때문에, 직접 찾아내기 전까진 서로 알 수 없음
    * 유니티 엔진 또한 어떤 오브젝트에 어떤 컴포넌트가 있는지 모르기에 유니티가 발동시키고 싶은 기능을 모두 오브젝트에 방송을 함, 메시지를 받은 오브젝트는 메시지에 명시되어진 기능을 가지고 있는 경우, 그 기능을 실행함

* 유니티 이벤트 메서드
    * Start()
    * Update()
    * OnTriggerEnter()
    * 등
    * 각 메서드들은 이름을 똑같이 구현해두면 메시지에 의해 자동으로 실행되는 메서드임
